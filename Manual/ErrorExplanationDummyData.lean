import Manual.ErrorExplanation


/--
This error indicates that something went very wrong. For example, we might have

# Examples

## The classic vector one

```lean broken (name := foo)
example (v : Vector Nat n) (h : n = 1) : v = v := by
  rewrite [h]
```

```lean fixed (name := foo)
example (v : Vector Nat n) (h : n = 1) : v = v := by
  subst h <;> rfl
```

```output broken (name := foo)
tactic 'rewrite' failed, motive is not type correct:
  fun _a => v = v
Error: application type mismatch
  Eq v
argument
  v
has type
  Vector Nat n : Type
but is expected to have type
  Vector Nat _a : Type

Explanation: The rewrite tactic rewrites an expression 'e' using an equality 'a = b' by the following process. First, it looks for all 'a' in 'e'. Second, it tries to abstract these occurrences of 'a' to create a function 'm := fun _a => ...', called the *motive*, with the property that 'm a' is definitionally equal to 'e'. Third, we observe that 'congrArg' implies that 'm a = m b', which can be used with lemmas such as 'Eq.mpr' to change the goal. However, if 'e' depends on specific properties of 'a', then the motive 'm' might not typecheck.

Possible solutions: use rewrite's 'occs' configuration option to limit which occurrences are rewritten, or use 'simp' or 'conv' mode, which have strategies for certain kinds of dependencies (these tactics can handle proofs and 'Decidable' instances whose types depend on the rewritten term, and 'simp' can apply user-defined '@[congr]' theorems as well).
n : Nat
v : Vector Nat n
h : n = 1
⊢ v = v
```

-/
register_error_explanation Lean.MotiveNotTypeCorrect {
  summary  := "Motive generated by a rewriting tactic does not yield the correct goal."
  sinceVersion := "4.0.0"
}

/--
For the sake of time, I won't even bother writing examples.
-/
register_error_explanation Lean.MyGreatTypeCorrectGoal {
  summary  := "Your goal was excessively type correct."
  sinceVersion := "4.0.0"
}

/--

This error appears when things go wrong.

# Examples

## Untyped parameter whose type cannot be inferred

```lean broken (name := hello)
def f x := 32
```
```lean fixed (name := hello)
def f (x : Nat) := 32
```
```output broken (name := hello)
failed to infer binder type
```

We can fix this by typing our binder.
If we fail to give a type to our binder, we get the error above.

Here's an unnamed block that must compile:
```lean
def x := 32
```

## More complicated definition to test `some` **things**

```lean broken (name := demo2)
inductive GenList (f : Option Type → Type) : Type
  | sing : f none → GenList f
  | cons : (xs : GenList f) → f xs → GenList f
```

```lean fixed (name := demo2)
inductive GenList (f : Option Type → Type) : Type
  | sing : f none → GenList f
  | cons : (xs : GenList f) → GenList f
```

```output broken (name := demo2)
application type mismatch
  f xs
argument
  xs
has type
  GenList f : Type
but is expected to have type
  Option Type : Type 1
```

## Example with multiple commands

```lean broken (name := demo3)
def f (x : Nat) := x + 1
def g (x : Nat) := f x + g x
```
```lean fixed (name := demo3)
def f (x : Nat) := x + 1
def g (x : Nat) := f x + f x
```
```output broken (name := demo3)
fail to show termination for
  g
with errors
failed to infer structural recursion:
Not considering parameter x of g:
  it is unchanged in the recursive calls
no parameters suitable for structural recursion

well-founded recursion cannot be used, 'g' does not take any (non-fixed) arguments
```
-/
register_error_explanation BadDocstring2 {
  summary := "A docstring test."
  sinceVersion := "4.0.0"
}

/--
A bad import.

# Examples

## Forgot import

```lean broken (name := demo1)
#check Lean.MetaM
```
```lean fixed (name := demo1)
import Lean
#check Lean.MetaM
```
```output broken (name := demo1)
unknown identifier 'Lean.MetaM'
```

## Not actually import, but parse error
```lean broken (name := demo5)
deffoo x := x + 32
```
```lean fixed (name := demo5)
def foo x := x + 32
```
```output broken (name := demo5)
unexpected identifier; expected command
```

## Slightly less disastrous parse error
```lean broken (name := demo7)
def a := 41
deffoo x := x + 32
def b := 49
```
```lean fixed (name := demo7)
def a := 41
def foo x := x + 32
def b := 49
```
```output broken (name := demo7)
function expected at
  41
term has type
  ?m.48
```

## Mistyped header

```lean broken (name := demo4)
import Wean

-- There should be a line break before and after this line

#check Lean.MetaM
```
```lean fixed (name := demo4)
import Lean

-- There should be a line break before and after this line

#check Lean.MetaM
```
```output broken (name := demo4)
unknown module prefix 'Wean'

No directory 'Wean' or file 'Wean.olean' in the search path entries:
././.lake/packages/subverso/.lake/build/lib/lean
././.lake/packages/MD4Lean/.lake/build/lib/lean
././.lake/packages/verso/.lake/build/lib/lean
././.lake/build/lib/lean
/Users/jrr6/.elan/toolchains/leanprover--lean4---v4.19.0-rc2/lib/lean
```
-/
register_error_explanation BadImport {
  summary := "Missing import testing."
  sinceVersion := "4.0.0"
}
