import Manual.ErrorExplanation


/--
This error indicates that something went very wrong. For example, we might have
done something ill-advised.

# Examples

## The classic vector one

```lean broken
example (v : Vector Nat n) (h : n = 1) : v = v := by
  rewrite [h]
```
```output broken
tactic 'rewrite' failed, motive is not type correct:
  fun _a => v = v
Error: application type mismatch
  Eq v
argument
  v
has type
  Vector Nat n : Type
but is expected to have type
  Vector Nat _a : Type

Explanation: The rewrite tactic rewrites an expression 'e' using an equality 'a = b' by the following process. First, it looks for all 'a' in 'e'. Second, it tries to abstract these occurrences of 'a' to create a function 'm := fun _a => ...', called the *motive*, with the property that 'm a' is definitionally equal to 'e'. Third, we observe that 'congrArg' implies that 'm a = m b', which can be used with lemmas such as 'Eq.mpr' to change the goal. However, if 'e' depends on specific properties of 'a', then the motive 'm' might not typecheck.

Possible solutions: use rewrite's 'occs' configuration option to limit which occurrences are rewritten, or use 'simp' or 'conv' mode, which have strategies for certain kinds of dependencies (these tactics can handle proofs and 'Decidable' instances whose types depend on the rewritten term, and 'simp' can apply user-defined '@[congr]' theorems as well).
n : Nat
v : Vector Nat n
h : n = 1
⊢ v = v
```

```lean fixed
example (v : Vector Nat n) (h : n = 1) : v = v := by
  subst h <;> rfl
```

-/
register_error_explanation Lean.MotiveNotTypeCorrect {
  summary  := "Motive generated by a rewriting tactic does not yield the correct goal."
  sinceVersion := "4.0.0"
}

/--
For the sake of time, I won't even bother writing examples.
-/
register_error_explanation Lean.AGreatTypeCorrectGoal {
  summary  := "Your goal was excessively type correct."
  sinceVersion := "4.0.0"
}

/--

This error appears when things go wrong.

# Examples

## Untyped parameter whose type cannot be inferred

```lean broken
def f x := 32
```
```output broken
failed to infer binder type
```
```lean fixed
def f (x : Nat) := 32
```

We can fix this by typing our binder.
If we fail to give a type to our binder, we get the error above.

Here's an unnamed block that must compile:
```lean
def x := 32
```

## More complicated definition to test `some` **things**

```lean broken
inductive GenList (f : Option Type → Type) : Type
  | sing : f none → GenList f
  | cons : (xs : GenList f) → f xs → GenList f
```

```output broken
application type mismatch
  f xs
argument
  xs
has type
  GenList f : Type
but is expected to have type
  Option Type : Type 1
```

```lean fixed (title := "Remove the f")
inductive GenList (f : Option Type → Type) : Type
  | sing : f none → GenList f
  | cons : (xs : GenList f) → GenList f
```

```lean fixed (title := "Remove Everything")
inductive GenList (f : Option Type → Type) : Type
  | sing : f none → GenList f
  | cons : GenList f
```

## Example with multiple commands

```lean broken
def f (x : Nat) := x + 1
def g (x : Nat) := f x + g x
```
```output broken
fail to show termination for
  g
with errors
failed to infer structural recursion:
Not considering parameter x of g:
  it is unchanged in the recursive calls
no parameters suitable for structural recursion

well-founded recursion cannot be used, 'g' does not take any (non-fixed) arguments
```
```lean fixed
def f (x : Nat) := x + 1
def g (x : Nat) := f x + f x
```
-/
register_error_explanation Lean.BadDocstring2 {
  summary := "A docstring test."
  sinceVersion := "4.0.0"
}

/--
A bad import.

# Examples

## Forgot import

```lean broken
#check Lean.MetaM
```
```output broken
unknown identifier 'Lean.MetaM'
```
```lean fixed
import Lean
#check Lean.MetaM
```

## Not actually import, but parse error
```lean broken
deffoo x := x + 32
```
```output broken
unexpected identifier; expected command
```
```lean fixed
def foo x := x + 32
```

## Slightly less disastrous parse error
```lean broken
def a := 41
deffoo x := x + 32
def b := 49
```
```output broken
function expected at
  41
term has type
  ?m.48
```
```lean fixed
def a := 41
def foo x := x + 32
def b := 49
```

-- ## Mistyped header

-- ```lean broken
-- import Wean

-- -- There should be a line break before and after this line

-- #check Lean.MetaM
-- ```
-- ```output broken
-- unknown module prefix 'Wean'

-- No directory 'Wean' or file 'Wean.olean' in the search path entries:
-- ././.lake/packages/subverso/.lake/build/lib/lean
-- ././.lake/packages/MD4Lean/.lake/build/lib/lean
-- ././.lake/packages/verso/.lake/build/lib/lean
-- ././.lake/build/lib/lean
-- /Users/jrr6/.elan/toolchains/leanprover--lean4---v4.19.0-rc2/lib/lean
-- ```
-- ```lean fixed
-- import Lean

-- -- There should be a line break before and after this line

-- #check Lean.MetaM
-- ```
-/
register_error_explanation Lean.BadImport {
  summary := "Missing import testing."
  sinceVersion := "4.0.0"
}

/--
This error explanation exists to test handling of removed errors.

[This](lean-manual://section/tactics) should be a valid manual link.
-/
register_error_explanation Lean.AnOldError {
  summary := "An error that used to be thrown but no longer is."
  sinceVersion := "4.0.0"
  removedVersion := "4.18.0"
}

/--
This error occurs when a parameter of an inductive type is not uniform in an inductive declaration. The parameters of an inductive type (i.e., those that appear before the colon following the `inductive` keyword) must be identical in all occurrences of the type being defined in its constructors' types. If a parameter of an inductive type must vary between constructors, make the parameter an index by moving it to the right of the colon. See the manual section on [Inductive Types](lean-manual://section/inductive-types) for additional details.

This error also occurs if the type constructor being defined is only partially applied to its parameters: for instance, if the type constructor itself is being passed as the argument to a function. In such a construction, all arguments omitted from the partial application must be indices, not parameters.

Note that auto-implicit inlay hints always appear left of the colon in an inductive declaration (i.e., as parameters), even when they are actually indices. This means that double-clicking on an inlay hint to insert such parameters may result in this error. If it does, change the inserted parameters to indices.

# Examples

## Vector length index as a parameter

```lean broken
inductive Vec (α : Type) (n : Nat) : Type where
  | nil  : Vec α 0
  | cons : α → Vec α n → Vec α (n + 1)
```
```output broken
inductive datatype parameter mismatch
  0
expected
  n
```
```lean fixed
inductive Vec (α : Type) : Nat → Type where
  | nil  : Vec α 0
  | cons : α → Vec α n → Vec α (n + 1)
```

The length argument `n` of the `Vec` type constructor is declared as a parameter, but other values for this argument appear in the `nil` and `cons` constructors (namely, `0` and `n + 1`). An error therefore appears at the first occurrence of such an argument. To correct this, `n` cannot be a parameter of the inductive declaration and must instead be an index, as in the corrected example. On the other hand, `α` remains unchanged throughout all occurrences of `Vec` in the declaration and so is a valid parameter.
-/
register_error_explanation Lean.InductiveParamMismatch {
  summary := "Invalid parameter in an occurrence of an inductive type in one of its constructors."
  sinceVersion := "4.0.0"
}
